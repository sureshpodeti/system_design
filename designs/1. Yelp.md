# Yelp System design
Store the location of different business (eg. restaurants, coffee shops, etc) and enable user to search/view the near by places based on current location.
##  Algorithm
Store the locations, and retrieve them effectively and efficiently.

## Techniques

### SQL Solution
Store the location of each business in **location** table with two columns **latitude and longitude**. Have **indexes** on the both the columns for faster search

For searching the table query would look like:

    select *from locations where latitude between X-D and X-D and longitude between Y-D and Y+D;
    
X, Y are current user locatin, and D is the search distance radius. Above query will fetch two large lists, and perform the interesection of two lists which is very expensive.

![Tux, the Linux mascot](/assets/3.png)


### Grid solution
Let's assume entire 2D world map is divided into small grids of size equal to D (the search distance). Each grid will have group of places. Given a (lat, long) we have to find out which grid the (lat, long) belongs to, and this way we only have to search the grid the (lat, long) belongs and the neighboring 8 grids.

Add extra field **gridId** to the locations table, and index it for the faster search

Pre-compute the gridId for each point and store it in the gridId column.

Sql query will be changed to:

        select *from locations where latitude between X-D and X+D and longitude between Y-D and Y+D and gridID in (gridId, gridId1, gridID2, gridID3, gridID4, gridID5, gridID6, gridID7, gridID8);
        
Above will improve the run time of the query (SQl will figureout the optimal way to find the intersection in where clause)
 ![Tux, the Linux mascot](/assets/5.png)


 Sample grid:
 ![Tux, the Linux mascot](/assets/4.png)
 
     
 #### How to know the gridId from (lat, long) , and How to compute the grid neighbors given the gridId? [Ideone code link](https://ideone.com/rc15jv).
      
        #include <iostream>
        #define gridSize 2
        #define noOfGrids 5 // World map is of size noOfGrids x noOfGrids
        #include<cmath>
        #include<vector>
        #include<queue>
        using namespace std;

        int getGridID(int lat, int lng){

            int row = ceil(float(lng) / float(gridSize));
            int col = ceil(float(lat) / float(gridSize)); 

            return (row-1)*noOfGrids + col;

        }

        vector<int> getGridNeighbors(int gridID){
            vector<int> vect;

            queue<int> q;

            q.push(gridID);

            if(gridID-noOfGrids>0)
                q.push(gridID-noOfGrids);

            if(gridID+noOfGrids<=noOfGrids*noOfGrids)
                q.push(gridID+noOfGrids);

            while(!q.empty()){
                int front = q.front();
                q.pop();

                vect.push_back(front);
                if(front-1>0 && (front-1)%noOfGrids!=0)
                    vect.push_back(front-1);

                if(front+1<=noOfGrids*noOfGrids && front%noOfGrids!=0)
                    vect.push_back(front+1);

            }

           return vect;

        }
        int main()
        {
           int arr[noOfGrids][noOfGrids];

           int gridID  = getGridID(3, 1);

           cout << gridID << endl;


           vector<int> gridNeighbors = getGridNeighbors(gridID);

           for(auto neighbor: gridNeighbors)
               cout << neighbor << " ";
            cout << endl;


            return 0;
        }
 
